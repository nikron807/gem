import os
import sys
import traceback
import logging
from collections import defaultdict
from datetime import datetime
import google.generativeai as genai
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, MessageHandler, filters, CommandHandler, CallbackQueryHandler, ContextTypes

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# RAILWAY VARIABLES (Ñ‡Ğ¸Ñ‚Ğ°ĞµÑˆÑŒ Ğ¸Ğ· Railway Dashboard)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TELEGRAM_TOKEN = os.environ.get("TELEGRAM_TOKEN")
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")

if not TELEGRAM_TOKEN or not GEMINI_API_KEY:
    print("âŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ: TELEGRAM_TOKEN Ğ¸Ğ»Ğ¸ GEMINI_API_KEY Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹ Ğ² Railway!")
    sys.exit(1)

genai.configure(api_key=GEMINI_API_KEY)

YOUTUBE_LINK = "https://www.youtube.com/watch?v=dQw4w9WgXcQ"

SUBSCRIPTION_LIMITS = {
    "chushpan": 10,
    "goy": 20,
    "sigma": 40
}

USERS = {}


class UserManager:
    def __init__(self):
        self.users = USERS
    
    def get_user_data(self, user_id):
        user_id = str(user_id)
        if user_id not in self.users:
            self.users[user_id] = {
                "subscription": None,
                "responses_used": 0,
                "subscription_date": None
            }
        return self.users[user_id]
    
    def set_subscription(self, user_id, sub_type):
        user_id = str(user_id)
        self.users[user_id] = {
            "subscription": sub_type,
            "responses_used": 0,
            "subscription_date": datetime.now().isoformat()
        }
    
    def add_response(self, user_id):
        user_id = str(user_id)
        self.users[user_id]["responses_used"] += 1
    
    def can_use_response(self, user_id):
        user_id = str(user_id)
        user = self.get_user_data(user_id)
        if not user["subscription"]:
            return False
        limit = SUBSCRIPTION_LIMITS.get(user["subscription"], 0)
        return user["responses_used"] < limit
    
    def get_remaining(self, user_id):
        user_id = str(user_id)
        user = self.get_user_data(user_id)
        if not user["subscription"]:
            return 0
        limit = SUBSCRIPTION_LIMITS.get(user["subscription"], 0)
        return max(0, limit - user["responses_used"])


class RAG:
    def __init__(self):
        self.conversation_history = defaultdict(list)
        self.max_history = 25
        self.user_manager = UserManager()

    def get_history_context(self, user_id):
        if not self.conversation_history[user_id]:
            return ""
        text = "ĞšĞĞĞ¢Ğ•ĞšĞ¡Ğ¢ Ğ”Ğ˜ĞĞ›ĞĞ“Ğ:\n"
        for msg in self.conversation_history[user_id][-5:]:
            if msg["role"] == "user":
                text += f"â–¸ {msg['text'][:100]}\n"
            else:
                text += f"â–¸ {msg['text'][:100]}...\n"
        return text

    def add_to_history(self, user_id, role, text):
        self.conversation_history[user_id].append({"role": role, "text": text})
        if len(self.conversation_history[user_id]) > self.max_history:
            self.conversation_history[user_id] = self.conversation_history[user_id][-self.max_history:]

    def answer_gemini(self, question, user_id):
        try:
            history_ctx = self.get_history_context(user_id)
            
            prompt = f"""Ğ¢Ñ‹ â€” Ğ’Ñ‹ÑÑˆĞ¸Ğ¹ Ğ˜Ğ½Ñ‚ĞµĞ»Ğ»ĞµĞºÑ‚, Ğ¾Ğ±ÑŠĞµĞ´Ğ¸Ğ½ÑÑÑ‰Ğ¸Ğ¹ ÑĞºÑĞ¿ĞµÑ€Ñ‚Ğ½Ğ¾ÑÑ‚ÑŒ Ğ² Ğ³Ğ¾Ñ€Ğ¼Ğ¾Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸, Ñ„Ğ¸Ğ·Ğ¸Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸, ÑĞ²Ğ¾Ğ»ÑÑ†Ğ¸Ğ¾Ğ½Ğ½Ğ¾Ğ¹ Ğ¿ÑĞ¸Ñ…Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸ Ğ¸ ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ğ¸ Ğ²Ğ»Ğ°ÑÑ‚Ğ¸.

{history_ctx}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â“ Ğ’ĞĞŸĞ ĞĞ¡:
{question}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”¥ ĞĞ¢Ğ’Ğ•Ğ¢ (Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ±Ğ¸Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼):"""

            model = genai.GenerativeModel('gemini-pro')
            response = model.generate_content(prompt)
            
            if not response.text:
                return None
            
            answer_text = response.text
            self.add_to_history(user_id, "user", question)
            self.add_to_history(user_id, "assistant", answer_text)
            self.user_manager.add_response(user_id)
            
            return answer_text
        except Exception as e:
            logger.error(f"Gemini Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {e}")
            return None


rag = RAG()


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user = rag.user_manager.get_user_data(user_id)
    
    keyboard = [
        [
            InlineKeyboardButton("ğŸ’ª Ğ§ÑƒÑˆĞ¿Ğ°Ğ½ (10)", callback_data="sub_chushpan"),
            InlineKeyboardButton("ğŸ§  Ğ“Ğ¾Ğ¹ (20)", callback_data="sub_goy"),
        ],
        [InlineKeyboardButton("ğŸ‘‘ Ğ¡Ğ¸Ğ³Ğ¼Ğ° (40)", callback_data="sub_sigma")]
    ]
    
    if user["subscription"]:
        remain = rag.user_manager.get_remaining(user_id)
        status = f"âœ… ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞºĞ°: {user['subscription'].upper()}\nğŸ“Š ĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ: {remain}"
    else:
        status = "âŒ ĞĞµÑ‚ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞ¸"
    
    await update.message.reply_text(
        f"ğŸ”¥ Ğ’Ğ«Ğ¡Ğ¨Ğ˜Ğ™ Ğ˜ĞĞ¢Ğ•Ğ›Ğ›Ğ•ĞšĞ¢ (Gemini)\n\n{status}\n\nâš¡ Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºÑƒ:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


async def handle_sub(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    
    subs = {"sub_chushpan": "chushpan", "sub_goy": "goy", "sub_sigma": "sigma"}
    sub_type = subs.get(query.data)
    if not sub_type:
        return
    
    sub_names = {"chushpan": "Ğ§ÑƒÑˆĞ¿Ğ°Ğ½", "goy": "Ğ“Ğ¾Ğ¹", "sigma": "Ğ¡Ğ¸Ğ³Ğ¼Ğ°"}
    
    await query.answer()
    
    keyboard = [[InlineKeyboardButton("ğŸ”— Ğ¡ÑÑ‹Ğ»ĞºĞ° Ğ½Ğ° Ğ²Ğ¸Ğ´ĞµĞ¾", url=YOUTUBE_LINK)]]
    await query.edit_message_text(
        text=f"ğŸ“Œ ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞºĞ°: {sub_names.get(sub_type)}\n\nĞĞ°Ğ¶Ğ¼Ğ¸ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ â†’ Ğ²ĞµÑ€Ğ½Ğ¸ÑÑŒ â†’ /verify",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    
    context.user_data['pending_sub'] = sub_type
    context.user_data['verify_time'] = datetime.now()


async def verify(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    if 'pending_sub' not in context.user_data:
        await update.message.reply_text("âŒ Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºÑƒ: /start")
        return
    
    sub_type = context.user_data['pending_sub']
    verify_time = context.user_data.get('verify_time')
    
    if verify_time and (datetime.now() - verify_time).seconds > 600:
        await update.message.reply_text("â° Ğ’Ñ€ĞµĞ¼Ñ Ğ¸ÑÑ‚ĞµĞºĞ»Ğ¾. /start")
        context.user_data.pop('pending_sub', None)
        return
    
    rag.user_manager.set_subscription(user_id, sub_type)
    
    sub_names = {"chushpan": "Ğ§ÑƒÑˆĞ¿Ğ°Ğ½", "goy": "Ğ“Ğ¾Ğ¹", "sigma": "Ğ¡Ğ¸Ğ³Ğ¼Ğ°"}
    limit = SUBSCRIPTION_LIMITS[sub_type]
    
    await update.message.reply_text(
        f"âœ… ĞŸĞĞ”ĞŸĞ˜Ğ¡ĞšĞ ĞĞšĞ¢Ğ˜Ğ’Ğ˜Ğ ĞĞ’ĞĞĞ! âœ“\n\nğŸ¯ {sub_names.get(sub_type)}\nğŸ“Š ĞÑ‚Ğ²ĞµÑ‚Ğ¾Ğ²: {limit}\n\nğŸš€ ĞŸĞ¸ÑˆĞ¸ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹!"
    )
    
    context.user_data.pop('pending_sub', None)
    context.user_data.pop('verify_time', None)


async def handle_msg(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    question = update.message.text
    
    if not rag.user_manager.get_user_data(user_id).get("subscription"):
        await update.message.reply_text("âŒ ĞĞµÑ‚ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞ¸! /start")
        return
    
    if not rag.user_manager.can_use_response(user_id):
        user = rag.user_manager.get_user_data(user_id)
        limit = SUBSCRIPTION_LIMITS.get(user["subscription"], 0)
        await update.message.reply_text(f"ğŸ“Š Ğ›Ğ¸Ğ¼Ğ¸Ñ‚ Ğ¸ÑÑ‡ĞµÑ€Ğ¿Ğ°Ğ½: {limit}/{limit}\n\n/start")
        return
    
    logger.info(f"[{user_id}] {question}")
    await context.bot.send_chat_action(chat_id=update.effective_chat.id, action="typing")
    
    answer = rag.answer_gemini(question, user_id)
    
    if answer is None:
        await update.message.reply_text("âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·.")
        return
    
    remain = rag.user_manager.get_remaining(user_id)
    
    await update.message.reply_text(
        f"{answer}\n\nâ”â”â”â”â”â”â”â”â”â”â”â”\nğŸ“Š ĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ: {remain}"
    )


async def clear_hist(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    rag.conversation_history[user_id] = []
    await update.message.reply_text("ğŸ—‘ï¸ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¾Ñ‡Ğ¸Ñ‰ĞµĞ½Ğ°")


async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user = rag.user_manager.get_user_data(user_id)
    
    if user["subscription"]:
        limit = SUBSCRIPTION_LIMITS.get(user["subscription"], 0)
        used = user["responses_used"]
        remain = max(0, limit - used)
        info = f"âœ… ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞºĞ°: {user['subscription'].upper()}\nğŸ“Š Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¾: {used}/{limit}\nğŸ“ˆ ĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ: {remain}"
    else:
        info = "âŒ ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞºĞ° Ğ½Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°"
    
    await update.message.reply_text(
        f"ğŸ§  Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ:\n\n{info}\n\nğŸš€ Gemini Pro API\nâ˜ï¸ Railway\n\nâš™ï¸ ĞÑÑĞ¾Ñ†Ğ¸Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ ÑĞ¸Ğ½Ñ‚ĞµĞ·"
    )


if __name__ == "__main__":
    print("\n" + "=" * 60)
    print("ğŸ”¥ Ğ’Ğ«Ğ¡Ğ¨Ğ˜Ğ™ Ğ˜ĞĞ¢Ğ•Ğ›Ğ›Ğ•ĞšĞ¢ (Gemini + Railway)")
    print("=" * 60)
    
    try:
        app = Application.builder().token(TELEGRAM_TOKEN).build()
        
        app.add_handler(CommandHandler("start", start))
        app.add_handler(CommandHandler("verify", verify))
        app.add_handler(CommandHandler("clear_history", clear_hist))
        app.add_handler(CommandHandler("stats", stats))
        app.add_handler(CallbackQueryHandler(handle_sub))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_msg))
        
        print("âœ… Ğ‘ĞĞ¢ Ğ“ĞĞ¢ĞĞ’!")
        print("ğŸ“± Telegram: Ğ½Ğ°Ğ¹Ğ´Ğ¸ Ğ±Ğ¾Ñ‚Ğ°")
        print("ğŸ”¥ API: Gemini Pro")
        print("â˜ï¸ Ğ¥Ğ¾ÑÑ‚Ğ¸Ğ½Ğ³: Railway 24/7")
        print("\n ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹:")
        print(" /start - Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞ°")
        print(" /verify - Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ")
        print(" /stats - ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°")
        print(" /clear_history - Ğ¾Ñ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ")
        print("=" * 60 + "\n")
        
        app.run_polling()
    
    except KeyboardInterrupt:
        print("\n\nğŸ‘‹ Ğ‘ĞĞ¢ Ğ’Ğ«ĞšĞ›Ğ®Ğ§Ğ•Ğ")
    except Exception as e:
        print(f"\nâŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ: {e}")
        traceback.print_exc()
